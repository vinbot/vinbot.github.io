<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeetCode 150 Study Companion</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <!-- PrismJS for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <style>
        :root {
            /* Fallback for browsers that don't support the JS fix */
            --vh: 1vh;
        }
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #f1f5f9; /* bg-slate-100 */
        }
        .scroll-container {
            height: 100vh; /* Fallback */
            height: calc(var(--vh, 1vh) * 100);
            overflow-y: scroll;
            scroll-snap-type: y mandatory;
        }
        .scroll-card {
            scroll-snap-align: start;
            height: 100vh; /* Fallback */
            height: calc(var(--vh, 1vh) * 100);
            display: flex;
            flex-direction: column;
            padding: 1rem;
        }
        /* Flip card styles */
        .flip-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        .flip-card.is-flipped .flip-card-inner {
            transform: rotateY(180deg);
        }
        .flip-card-front, .flip-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden; /* Safari */
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            border-radius: 1rem; /* rounded-2xl */
            border: 1px solid #e2e8f0; /* border-slate-200 */
            background-color: white;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .flip-card-back {
            transform: rotateY(180deg);
        }
        .card-content {
            flex-grow: 1;
            overflow-y: auto;
        }
        .card-content::-webkit-scrollbar { width: 4px; }
        .card-content::-webkit-scrollbar-track { background: transparent; }
        .card-content::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 2px; }
        
        pre, code {
            font-family: 'JetBrains Mono', monospace;
        }
        /* Overriding PrismJS theme defaults for better integration */
        pre[class*="language-"] {
            border-radius: 0.5rem;
            padding: 1rem;
            font-size: 0.875rem;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body>

    <div id="scroll-container" class="scroll-container">
        <!-- Loading state -->
        <div id="loading-indicator" class="flex h-full items-center justify-center text-center">
            <div>
                <svg class="animate-spin h-8 w-8 text-slate-500 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <p class="mt-2 text-slate-500">Loading all 150 problems...</p>
            </div>
        </div>
        <!-- Problem cards will be injected here -->
    </div>
    
    <!-- PrismJS for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <!-- JSON Data with descriptions and solutions -->
    <script id="neetcode-data" type="application/json">
    {
      "topics": [
        {
          "topic_name": "Arrays & Hashing",
          "problems": [
            {"id": 217, "title": "Contains Duplicate", "difficulty": "Easy", "link": "https://leetcode.com/problems/contains-duplicate/", "description": "Given an integer array `nums`, determine if any value appears at least twice in the array. Return `true` if a duplicate exists, otherwise return `false`.", "details": {"key_idea": "Use a hash set to store unique elements as we traverse the list. If an element is already present in the set, we have found a duplicate.", "time_complexity": "O(n)", "space_complexity": "O(n)", "python_solution": "class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        hashset = set()\n\n        for n in nums:\n            if n in hashset:\n                return True\n            hashset.add(n)\n        return False"}},
            {"id": 242, "title": "Valid Anagram", "difficulty": "Easy", "link": "https://leetcode.com/problems/valid-anagram/", "description": "Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise. An anagram is a word formed by rearranging the letters of another, using all original letters exactly once.", "details": {"key_idea": "Use a hash map to count character frequencies for each string. If the frequency maps are identical, they are anagrams.", "time_complexity": "O(n)", "space_complexity": "O(1)", "python_solution": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n\n        char_frequency = {}\n\n        for char in s:\n            char_frequency[char] = char_frequency.get(char, 0) + 1\n\n        for char in t:\n            if char not in char_frequency or char_frequency[char] == 0:\n                return False\n            char_frequency[char] -= 1\n\n        return True"}},
            {"id": 1, "title": "Two Sum", "difficulty": "Easy", "link": "https://leetcode.com/problems/two-sum/", "description": "Given an array of integers `nums` and a `target`, return indices of the two numbers that add up to `target`. Assume exactly one solution exists and you may not use the same element twice.", "details": {"key_idea": "Use a hash map to store elements and their indices. For each element, calculate the required complement (`target` - `num`) and check if it's in the map.", "time_complexity": "O(n)", "space_complexity": "O(n)", "python_solution": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        prevMap = {}\n\n        for i, n in enumerate(nums):\n            diff = target - n\n            if diff in prevMap:\n                return [prevMap[diff], i]\n            prevMap[n] = i"}},
            {"id": 49, "title": "Group Anagrams", "difficulty": "Medium", "link": "https://leetcode.com/problems/group-anagrams/", "description": "Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.", "details": {"key_idea": "Use a hash map where the key is a sorted version of each word (or a character count tuple). The value will be a list of its anagrams.", "time_complexity": "O(n * m log m)", "space_complexity": "O(n * m)", "python_solution": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        anagrams_map = {}\n\n        for word in strs:\n            sorted_word = \"\".join(sorted(word))\n            if sorted_word in anagrams_map:\n                anagrams_map[sorted_word].append(word)\n            else:\n                anagrams_map[sorted_word] = [word]\n\n        return list(anagrams_map.values())"}},
            {"id": 347, "title": "Top K Frequent Elements", "difficulty": "Medium", "link": "https://leetcode.com/problems/top-k-frequent-elements/", "description": "Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in any order.", "details": {"key_idea": "Use a hash map for frequency counts. Then, use a min-heap of size `k` to keep track of the top `k` frequent elements, or use Bucket Sort for an O(n) solution.", "time_complexity": "O(n log k)", "space_complexity": "O(n)", "python_solution": "import heapq\n\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        frequency_map = {}\n        for num in nums:\n            frequency_map[num] = frequency_map.get(num, 0) + 1\n\n        min_heap = []\n        for num, frequency in frequency_map.items():\n            heapq.heappush(min_heap, (frequency, num))\n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n\n        return [num for frequency, num in min_heap]"}},
            {"id": 238, "title": "Product of Array Except Self", "difficulty": "Medium", "link": "https://leetcode.com/problems/product-of-array-except-self/", "description": "Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`. You must write an algorithm that runs in O(n) time and without using the division operation.", "details": {"key_idea": "Calculate prefix products in one pass (left-to-right) and suffix products in a second pass (right-to-left). The result for each index is the product of its corresponding prefix and suffix.", "time_complexity": "O(n)", "space_complexity": "O(1) (excluding output array)", "python_solution": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        result = [1] * n\n\n        left_product = 1\n        for i in range(n):\n            result[i] *= left_product\n            left_product *= nums[i]\n\n        right_product = 1\n        for i in range(n - 1, -1, -1):\n            result[i] *= right_product\n            right_product *= nums[i]\n\n        return result"}},
            {"id": 36, "title": "Valid Sudoku", "difficulty": "Medium", "link": "https://leetcode.com/problems/valid-sudoku/", "description": "Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the rules: Each row, column, and 3x3 sub-box must contain the digits 1-9 without repetition.", "details": {"key_idea": "Use sets to keep track of digits seen in each row, column, and 3x3 sub-grid. Traverse the board once, checking for duplicates.", "time_complexity": "O(1) (board is fixed size)", "space_complexity": "O(1)", "python_solution": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        seen = set()\n\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] != '.':\n                    num = board[i][j]\n                    if (\n                        (i, num) in seen\n                        or (num, j) in seen\n                        or (i // 3, j // 3, num) in seen\n                    ):\n                        return False\n                    seen.add((i, num))\n                    seen.add((num, j))\n                    seen.add((i // 3, j // 3, num))\n\n        return True"}},
            {"id": 271, "title": "Encode and Decode Strings", "difficulty": "Medium", "link": "https://leetcode.com/problems/encode-and-decode-strings/", "description": "Design an algorithm to encode a list of strings to a single string. The encoded string is then sent over the network and is decoded back to the original list of strings.", "details": {"key_idea": "Encode by prepending the length of each string followed by a delimiter (e.g., '4#neet'). Decode by parsing the length and then reading that many characters.", "time_complexity": "O(N) total chars", "space_complexity": "O(N) total chars", "python_solution": "class Codec:\n    def encode(self, strs: List[str]) -> str:\n        encoded = \"\"\n        for s in strs:\n            encoded += str(len(s)) + \"#\" + s\n        return encoded\n\n    def decode(self, s: str) -> List[str]:\n        decoded = []\n        i = 0\n        while i < len(s):\n            delimiter_pos = s.find(\"#\", i)\n            size = int(s[i:delimiter_pos])\n            start_pos = delimiter_pos + 1\n            end_pos = start_pos + size\n            decoded.append(s[start_pos:end_pos])\n            i = end_pos\n        return decoded"}},
            {"id": 128, "title": "Longest Consecutive Sequence", "difficulty": "Medium", "link": "https://leetcode.com/problems/longest-consecutive-sequence/", "description": "Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time.", "details": {"key_idea": "Use a set for O(1) lookups. For each number, check if it's the start of a sequence (num - 1 not in set). If so, count upwards until the sequence ends.", "time_complexity": "O(n)", "space_complexity": "O(n)", "python_solution": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        num_set = set(nums)\n        max_length = 0\n\n        for num in num_set:\n            if num - 1 not in num_set:\n                current_num = num\n                current_length = 1\n\n                while current_num + 1 in num_set:\n                    current_num += 1\n                    current_length += 1\n\n                max_length = max(max_length, current_length)\n\n        return max_length"}}
          ]
        },
        {
          "topic_name": "Two Pointers",
          "problems": [
            {"id": 125, "title": "Valid Palindrome", "difficulty": "Easy", "link": "https://leetcode.com/problems/valid-palindrome/", "description": "Given a string `s`, determine if it is a palindrome after converting all uppercase letters to lowercase and removing all non-alphanumeric characters.", "details": {"key_idea": "Use two pointers, one at the start and one at the end. Move them inwards, skipping non-alphanumeric characters, and compare the characters case-insensitively.", "time_complexity": "O(n)", "space_complexity": "O(1)", "python_solution": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        left, right = 0, len(s) - 1\n\n        while left < right:\n            while left < right and not s[left].isalnum():\n                left += 1\n            while left < right and not s[right].isalnum():\n                right -= 1\n\n            if s[left].lower() != s[right].lower():\n                return False\n\n            left += 1\n            right -= 1\n\n        return True"}},
            {"id": 167, "title": "Two Sum II - Input Array Is Sorted", "difficulty": "Medium", "link": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/", "description": "Given a 1-indexed array of integers `numbers` that is already sorted in non-decreasing order, find two numbers such that they add up to a specific `target` number.", "details": {"key_idea": "Since the array is sorted, use two pointers (left at start, right at end). If sum is too small, move left pointer up. If too large, move right pointer down.", "time_complexity": "O(n)", "space_complexity": "O(1)", "python_solution": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        left, right = 0, len(numbers) - 1\n\n        while left < right:\n            current_sum = numbers[left] + numbers[right]\n\n            if current_sum == target:\n                return [left + 1, right + 1]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n        return [-1, -1]"}},
            {"id": 15, "title": "3Sum", "difficulty": "Medium", "link": "https://leetcode.com/problems/3sum/", "description": "Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, `j != k`, and `nums[i] + nums[j] + nums[k] == 0`. The solution set must not contain duplicate triplets.", "details": {"key_idea": "Sort the array. Iterate with a main pointer `i`, then use two pointers (left and right) on the remainder of the array to find pairs that sum to -nums[i]. Skip duplicate elements to avoid duplicate triplets.", "time_complexity": "O(n^2)", "space_complexity": "O(1) or O(n) depending on sort", "python_solution": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        result = []\n        n = len(nums)\n\n        for i in range(n - 2):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n\n            left, right = i + 1, n - 1\n\n            while left < right:\n                current_sum = nums[i] + nums[left] + nums[right]\n\n                if current_sum == 0:\n                    result.append([nums[i], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n                elif current_sum < 0:\n                    left += 1\n                else:\n                    right -= 1\n\n        return result"}},
            {"id": 11, "title": "Container With Most Water", "difficulty": "Medium", "link": "https://leetcode.com/problems/container-with-most-water/", "description": "Given an integer array `height` of length `n`, find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store.", "details": {"key_idea": "Use two pointers at the ends of the array. Calculate the area. Move the pointer with the shorter height inward, as this is the only way to potentially increase the area.", "time_complexity": "O(n)", "space_complexity": "O(1)", "python_solution": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        left, right = 0, len(height) - 1\n        max_area = 0\n\n        while left < right:\n            current_area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, current_area)\n\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n\n        return max_area"}},
            {"id": 42, "title": "Trapping Rain Water", "difficulty": "Hard", "link": "https://leetcode.com/problems/trapping-rain-water/", "description": "Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.", "details": {"key_idea": "Use two pointers (left, right) and track max_left and max_right heights. The amount of water trapped at any point is determined by the minimum of max_left and max_right minus the current height.", "time_complexity": "O(n)", "space_complexity": "O(1)", "python_solution": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        left, right = 0, len(height) - 1\n        max_left, max_right = 0, 0\n        trapped_water = 0\n\n        while left < right:\n            if height[left] <= height[right]:\n                if height[left] >= max_left:\n                    max_left = height[left]\n                else:\n                    trapped_water += max_left - height[left]\n                left += 1\n            else:\n                if height[right] >= max_right:\n                    max_right = height[right]\n                else:\n                    trapped_water += max_right - height[right]\n                right -= 1\n\n        return trapped_water"}}
          ]
        },
        {
          "topic_name": "Sliding Window",
          "problems": [
            {"id": 121, "title": "Best Time to Buy & Sell Stock", "difficulty": "Easy", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/", "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `i-th` day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve. If you cannot achieve any profit, return 0.", "details": {"key_idea": "Iterate through the prices, keeping track of the minimum price seen so far (min_price) and the maximum profit found (current_price - min_price).", "time_complexity": "O(n)", "space_complexity": "O(1)", "python_solution": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if not prices:\n            return 0\n\n        min_price = float(\"inf\")\n        max_profit = 0\n\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n\n        return max_profit"}},
            {"id": 3, "title": "Longest Substring Without Repeating Characters", "difficulty": "Medium", "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters/", "description": "Given a string `s`, find the length of the longest substring without repeating characters.", "details": {"key_idea": "Use a sliding window with a set to track unique characters. Expand the window by moving the right pointer. If a duplicate is found, shrink the window from the left.", "time_complexity": "O(n)", "space_complexity": "O(k) where k is number of unique chars", "python_solution": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        left, right = 0, 0\n        max_length = 0\n        unique_chars = set()\n\n        while right < len(s):\n            if s[right] not in unique_chars:\n                unique_chars.add(s[right])\n                max_length = max(max_length, right - left + 1)\n                right += 1\n            else:\n                unique_chars.remove(s[left])\n                left += 1\n\n        return max_length"}},
            {"id": 424, "title": "Longest Repeating Character Replacement", "difficulty": "Medium", "link": "https://leetcode.com/problems/longest-repeating-character-replacement/", "description": "You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times. Return the length of the longest substring containing the same letter you can get after performing the above operations.", "details": {"key_idea": "The window is valid if (window_length - max_frequency) <= k. Use a sliding window and a frequency map. Expand the window, and if invalid, shrink from the left.", "time_complexity": "O(n)", "space_complexity": "O(1) (alphabet size is 26)", "python_solution": "class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        left, right = 0, 0\n        max_length = 0\n        char_freq = {}\n        max_freq = 0\n\n        while right < len(s):\n            char_freq[s[right]] = char_freq.get(s[right], 0) + 1\n            max_freq = max(max_freq, char_freq[s[right]])\n\n            if (right - left + 1) - max_freq > k:\n                char_freq[s[left]] -= 1\n                left += 1\n\n            max_length = max(max_length, right - left + 1)\n            right += 1\n\n        return max_length"}},
            {"id": 567, "title": "Permutation in String", "difficulty": "Medium", "link": "https://leetcode.com/problems/permutation-in-string/", "description": "Given two strings `s1` and `s2`, return `true` if `s2` contains a permutation of `s1`, or `false` otherwise. In other words, return `true` if one of `s1`'s permutations is the substring of `s2`.", "details": {"key_idea": "Use a sliding window of size len(s1) on s2. Maintain frequency maps for s1 and the current window. If maps are equal, a permutation exists.", "time_complexity": "O(n)", "space_complexity": "O(1)", "python_solution": "class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        if len(s1) > len(s2):\n            return False\n\n        char_freq_s1 = {}\n        for char in s1:\n            char_freq_s1[char] = char_freq_s1.get(char, 0) + 1\n\n        left, right = 0, 0\n        char_freq_temp = {}\n\n        while right < len(s2):\n            char_freq_temp[s2[right]] = char_freq_temp.get(s2[right], 0) + 1\n\n            if right - left + 1 == len(s1):\n                if char_freq_temp == char_freq_s1:\n                    return True\n                char_freq_temp[s2[left]] -= 1\n                if char_freq_temp[s2[left]] == 0:\n                    del char_freq_temp[s2[left]]\n                left += 1\n\n            right += 1\n\n        return False"}},
            {"id": 76, "title": "Minimum Window Substring", "difficulty": "Hard", "link": "https://leetcode.com/problems/minimum-window-substring/", "description": "Given two strings `s` and `t`, return the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window. If there is no such substring, return an empty string `\"\"`.", "details": {"key_idea": "Use a sliding window. Expand the window until it contains all characters of t. Then, shrink the window from the left while it remains valid, updating the minimum length.", "time_complexity": "O(n)", "space_complexity": "O(k) where k is unique chars in t", "python_solution": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not s or not t:\n            return \"\"\n\n        char_freq_t = {}\n        for char in t:\n            char_freq_t[char] = char_freq_t.get(char, 0) + 1\n\n        left, right = 0, 0\n        char_freq_temp = {}\n        required_chars = len(char_freq_t)\n        formed_chars = 0\n        min_length = float(\"inf\")\n        min_window = \"\"\n\n        while right < len(s):\n            char_freq_temp[s[right]] = char_freq_temp.get(s[right], 0) + 1\n\n            if s[right] in char_freq_t and char_freq_temp[s[right]] == char_freq_t[s[right]]:\n                formed_chars += 1\n\n            while left <= right and formed_chars == required_chars:\n                if right - left + 1 < min_length:\n                    min_length = right - left + 1\n                    min_window = s[left : right + 1]\n\n                char_freq_temp[s[left]] -= 1\n                if s[left] in char_freq_t and char_freq_temp[s[left]] < char_freq_t[s[left]]:\n                    formed_chars -= 1\n\n                left += 1\n\n            right += 1\n\n        return min_window"}},
            {"id": 239, "title": "Sliding Window Maximum", "difficulty": "Hard", "link": "https://leetcode.com/problems/sliding-window-maximum/", "description": "You are given an array of integers `nums`, and a sliding window of size `k` moving from the very left to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.", "details": {"key_idea": "Use a deque to store indices. The deque is kept in decreasing order of element values. The front of the deque is always the max for the current window.", "time_complexity": "O(n)", "space_complexity": "O(k)", "python_solution": "from collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        if not nums or k <= 0:\n            return []\n\n        result = []\n        window = deque()\n\n        for i, num in enumerate(nums):\n            while window and nums[window[-1]] < num:\n                window.pop()\n\n            window.append(i)\n\n            if i - window[0] >= k:\n                window.popleft()\n\n            if i >= k - 1:\n                result.append(nums[window[0]])\n\n        return result"}}
          ]
        }
      ]
    }
    </script>

    <script>
        // --- Fix for 100vh on mobile browsers ---
        function setViewportHeight() {
            let vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }
        window.addEventListener('resize', setViewportHeight);
        setViewportHeight(); // Initial call

        // --- Main script to build the UI from JSON data ---
        document.addEventListener('DOMContentLoaded', () => {
            const dataElement = document.getElementById('neetcode-data');
            const data = JSON.parse(dataElement.textContent);
            const scrollContainer = document.getElementById('scroll-container');

            const difficultyColors = {
                'Easy': 'bg-green-100 text-green-800',
                'Medium': 'bg-orange-100 text-orange-800',
                'Hard': 'bg-red-100 text-red-800'
            };

            function createProblemCard(problem, topicName) {
                const cardWrapper = document.createElement('div');
                cardWrapper.className = 'scroll-card';

                const flipCard = document.createElement('div');
                flipCard.className = 'flip-card w-full h-full';
                flipCard.style.perspective = '1000px';

                const flipCardInner = document.createElement('div');
                flipCardInner.className = 'flip-card-inner';

                // --- Card Front ---
                const cardFront = document.createElement('div');
                cardFront.className = 'flip-card-front';
                cardFront.innerHTML = `
                    <header class="p-4 border-b border-slate-200 flex-shrink-0">
                        <p class="text-sm font-medium text-indigo-600">${topicName}</p>
                        <h2 class="text-2xl font-bold text-slate-800 mt-1">${problem.title}</h2>
                        <div class="flex items-center justify-between mt-2">
                            <span class="text-sm font-medium px-2.5 py-1 rounded-full ${difficultyColors[problem.difficulty]}">${problem.difficulty}</span>
                            <span class="text-sm text-slate-500">ID: ${problem.id}</span>
                        </div>
                    </header>
                    <div class="card-content p-6 space-y-4">
                        <h4 class="font-semibold text-slate-700">Problem Description</h4>
                        <p class="text-slate-600 leading-relaxed">${problem.description.replace(/`([^`]+)`/g, '<code class="bg-slate-100 text-slate-800 font-mono text-sm px-1 py-0.5 rounded">\$1</code>')}</p>
                    </div>
                    <footer class="p-4 mt-auto flex-shrink-0 border-t border-slate-200">
                        <button class="w-full text-center bg-indigo-600 text-white font-semibold py-3 rounded-lg hover:bg-indigo-500 transition-colors flip-button">
                            Flip to see Key Idea
                        </button>
                    </footer>
                `;

                // --- Card Back ---
                const cardBack = document.createElement('div');
                cardBack.className = 'flip-card-back';
                
                const sanitizedTopicName = topicName.replace(/[^a-zA-Z0-9-]/g, '').replace(/\s+/g, '-');
                const solutionContainerId = `solution-${sanitizedTopicName}-${problem.id}`;
                
                cardBack.innerHTML = `
                    <header class="p-4 border-b border-slate-200 flex-shrink-0">
                        <p class="text-sm font-medium text-indigo-600">${topicName}</p>
                        <h2 class="text-2xl font-bold text-slate-800 mt-1">${problem.title}</h2>
                         <div class="flex items-center justify-between mt-2">
                            <span class="text-sm font-medium px-2.5 py-1 rounded-full ${difficultyColors[problem.difficulty]}">${problem.difficulty}</span>
                            <a href="${problem.link}" target="_blank" class="text-sm text-indigo-600 hover:underline">View on LeetCode →</a>
                        </div>
                    </header>
                    <div class="card-content p-6 space-y-6">
                        <div>
                            <h4 class="font-semibold text-slate-700 mb-2">Key Idea</h4>
                            <p class="text-slate-600 leading-relaxed">${problem.details.key_idea || 'Not available.'}</p>
                        </div>
                        <div class="grid grid-cols-2 gap-4 text-center">
                            <div class="bg-slate-100 p-3 rounded-lg">
                                <p class="text-sm text-slate-500">Time Complexity</p>
                                <p class="font-mono font-medium text-slate-800">${problem.details.time_complexity || 'N/A'}</p>
                            </div>
                            <div class="bg-slate-100 p-3 rounded-lg">
                                <p class="text-sm text-slate-500">Space Complexity</p>
                                <p class="font-mono font-medium text-slate-800">${problem.details.space_complexity || 'N/A'}</p>
                            </div>
                        </div>
                        <div>
                            <button class="w-full text-left font-semibold text-slate-700 mb-2 solution-toggle-button">
                                <span class="arrow">▶</span> Python Solution
                            </button>
                            <div id="${solutionContainerId}" class="solution-container hidden">
                                <pre><code class="language-python">${problem.details.python_solution.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</code></pre>
                            </div>
                        </div>
                    </div>
                    <footer class="p-4 mt-auto flex-shrink-0 border-t border-slate-200">
                         <button class="w-full text-center bg-slate-200 text-slate-800 font-semibold py-3 rounded-lg hover:bg-slate-300 transition-colors flip-button">
                            Flip back to Description
                        </button>
                    </footer>
                `;

                flipCardInner.appendChild(cardFront);
                flipCardInner.appendChild(cardBack);
                flipCard.appendChild(flipCardInner);
                cardWrapper.appendChild(flipCard);

                // Add flip functionality
                cardWrapper.querySelectorAll('.flip-button').forEach(button => {
                    button.addEventListener('click', () => {
                        flipCard.classList.toggle('is-flipped');
                    });
                });
                
                // Add solution toggle functionality
                const solutionToggleButton = cardBack.querySelector('.solution-toggle-button');
                const solutionContainer = cardBack.querySelector(`#${solutionContainerId}`);
                solutionToggleButton.addEventListener('click', () => {
                    solutionContainer.classList.toggle('hidden');
                    const arrow = solutionToggleButton.querySelector('.arrow');
                    arrow.textContent = solutionContainer.classList.contains('hidden') ? '▶' : '▼';
                });


                return cardWrapper;
            }
            
            // Clear loading indicator and build UI
            scrollContainer.innerHTML = ''; 

            data.topics.forEach(topic => {
                topic.problems.forEach(problem => {
                    if (problem.details && problem.description && problem.details.python_solution) {
                        const card = createProblemCard(problem, topic.topic_name);
                        scrollContainer.appendChild(card);
                    }
                });
            });

            // Highlight all the new code blocks
            Prism.highlightAll();
        });
    </script>
</body>
</html>
